page Sysconf convention

  site-header Directory convention

  section
    h2 A way to centralize configuration files
    p Suppose you have a file, {e /etc/cron.daily/some-task}, that you need to share or backup across different systems:
    p
      e /etc/cron.daily/some-task
    p The idea is to move the file to a central versionned tree in {e /sysconf} and replace {e /etc/cron.daily/some-task} with a symbolic link pointing to it:
    p.expr.
      /etc/cron.daily/some-task -> /sysconf/actual/tree/etc/cron.daily/some-task
      /sysconf/actual/tree/etc/cron.daily/some-task
    p With this organisation, the /sysconf directory can be versionned, backed-up and synced between different systems.
    p And still, files can be edited in place as usual ({e /etc/cron.daily/some-task} in this example) while being tracked easily in {e /sysconf}, because of the symbolic links.

  section
    h2 Separating between profiles
    p In most cases, it is not enough to make a single separation between system-maintained files (managed by apt-get, yum, etc.) and custom sysconf-maintained files. Any system serves a purpose that can be structed in different layers. These layers are called profiles.
    section
      h3 Example: a developer team's desktop system
      p ... can be devided into these layers:
      ul
        li {i host-specific}: what is unique to this very system, for example {e /etc/hosts}; this layer is named: {e actual}
        li {i shared with team}: what is shared with the colleagues, for example a {e /usr/share/git-hook/commit-msg} script responsible for the validation of the team projects' commit messages; this layer is named: {e team}
        li {i personal settings}: what the developer shares with his home computer, for example shell aliases in {e /etc/bash.bashrc}; this layer is named: {e personal}

      p Profiles lie in their respective directory into {e /sysconf}:
      p.expr.
        /sysconf/actual/tree/etc/hosts
        /sysconf/sysconf.team/tree/usr/share/git-hook/commit-msg
        /sysconf/sysconf.personal/tree/etc/bash.bashrc
      p The symbolic links become as follows:
      p.expr.
        /etc/hosts                     -> /sysconf/actual/tree/etc/hosts
        /usr/share/git-hook/commit-msg -> /sysconf/sysconf.team/tree/usr/share/git-hook/commit-msg
        /etc/bash.bashrc               -> /sysconf/sysconf.personal/tree/etc/bash.bashrc

    section
      h3 Profile inheritance and file overloading
      p Overloading is a an Object-oriented programming concept which in our case lets a Sysconf profile define a file that is already defined by another profile.
      p Suppose you have a profile {e A} meant to customize profile {e B} with a more specific version of a given file, say, {e /etc/bash.bashrc}. We would have the following /sysconf tree:
      p.expr.
        /sysconf/sysconf.A/tree/etc/bash.bashrc
        /sysconf/sysconf.B/tree/etc/bash.bashrc
      p The symbolic link {e /etc/bash.bashrc} should point to {e A}'s, not {e B}'s. To indicate this, a deps file is created into {e /sysconf/sysconf.A} which specifies that {e A} depends on {e B}, that {e A} extends {e B}: {e A}'s tree takes precedence over {e B}'s tree.

    section
      h3 The root profile: actual
      p If profiles can extend each other, dependant profiles must be processed last. It is necessary to know what is the first profile: by convention, it is named actual. In Object-oriented programming it is said to be the final concrete class (profile).
      p Sysconf will start by processing {e /sysconf/actual}, then recurse into the profiles whose names are listed in {e /sysconf/actual/deps} and so on.

  section
    h2 Dynamic settings: the setup.rc script
    p Statically organised files are not enough when you need to generate some files, install packages or more generally, execute custom commands.
    p To do that, profiles may define an {e setup.rc} file containing shell commands which are executed the command sysconf update.
    p For multiple profiles, the {e setup.rc} scripts of the dependencies are executed before the {e setup.rc} script of the profile that depend on them.
    p In other words, if {e A} depends on {e B}, the order will be: (1) {e /sysconf/sysconf.A/setup.rc}, then (2) {e /sysconf/sysconf.B/setup.rc} .


  section
    h2 Splitting config into config.d/*.config
    p The conf.d pattern, widely used on the Debian GNU/Linux distribution among others, is about turning a configuration file (like conf) into a directory (like conf.d) where the config lies into multiple files.
    p Where the pattern is enabled, it is easy to have sysconf-managed files, for example: /etc/nginx/sites-available/, /etc/logrotate.d/, etc.
    p But there are programs distributed with a unique config file:
    ul
      li some allow include directives with wildcards: it is the case of {e /etc/network/interfaces} to which we can add: source {e /etc/network/interfaces.d/*.interfaces};
      li some allow include directives without wildcard: it is the case of {e /etc/gitconfig} where included files need to be listed explicitely under the {e [include]} section;
      li some do not allow any includes anyway: it is the case of {e /etc/hosts} which need to be updated in place with the concatenation of {e /etc/hosts/*.hosts}.
    p Once the mecanism is enabled for a particular file (for example, {e /etc/hosts}), every Sysconf profile can take advantage of it by providing its specific config ({e /etc/hosts/profile-a.hosts} for example) in a clean and non-obstrusive way.
    p This is why Sysconf provides sysconf-etc.d, a generic tool that fix the required config files, which are by default:
    ul
      li {e /etc/hosts} out of {e /etc/hosts/*.hosts}
      li {e /etc/ssh/ssh_config} out of {e /etc/ssh/ssh_config.d/*.ssh_config}
      li {e /etc/ssh/sshd_config} out of {e /etc/ssh/sshd_config.d/*.sshd_config}
      li {e /etc/gitconfig} out of {e /etc/gitconfig.d/*.gitconfig}
    p Other files can be acted upon, when specified through a {e .meta.conf} file in {e /etc/sysconf/etc.d}: see {e etc/sysconf/etc.d/README.md} for more information.

  site-footer

:end
